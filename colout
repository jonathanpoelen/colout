#!/bin/bash

usage() {
echo -ne "Add colors to a text stream in your terminal.\n\n"\
"$0 -h\n"\
"$0 -l [COLORS_AND_STYLES...]\n"\
"$0 [-rcanpo] [-s scale] [-u units] [-x awk_expr] [-X awk_expr] [-f awk_func] PATTERN [COLORS_AND_STYLES...] [-- ...]\n\n"\
" -l  (line) Colors the lines\n\n"\
" -r  (repeat/again) Apply PATTERN until there is no more matching.\n\n"\
" -a  (all) Loop on all PATTERN until there is no more matching.\n\n"\
" -c  (continue) Try PATTERN even if previous ones match.\n\n"\
" -n  (next) Each match passes to the next color.\n\n"\
" -p  (print) print awk/sed command.\n\n"\
" -o  (optimize) See man awk -o/--optimize.\n\n"\
" -s scale  'min,max' or 'max'. Apply colors linearly between min and max (0,100 by default).\n\n"\
" -u units  Cuts the color range per unit.\n\n"\
" -x awk_expr  An expression that returns the color index.\n"\
"              'v' the extracted value\n"\
"              'n' the number of color\n"\
"              'u' (only if -u) the unit position (1 is first unit, 0 is an unrecognized unit).\n\n"\
" -X awk_expr  An expression that returns a numeric value between min and max (see '-s scale').\n"\
"              'v' the extracted value\n"\
"              'n' the number of color\n"\
"              'u' (only if -u) the unit position (1 is first unit, 0 is an unrecognized unit).\n\n"\
" -f awk_func  Awk user functions.\n\n"\
"\n"\
" styles:\n"\
  "  normal,n\n"\
  "  bold,o\n"\
  "  d[im]\n"\
  "  i[talic]\n"\
  "  u[nderline]\n"\
  "  blink,l\n"\
  "  reverse,v\n"\
  "  [h]idden\n\n"\
" named colors (Note: an uppercase character is considered to be bold)\n"\
  "  default,none\n"\
  "  [blac]k\n"\
  "  w[hite]\n"\
  "  r[ed]\n"\
  "  g[reen]\n"\
  "  b[lue]\n"\
  "  y[ellow]\n"\
  "  m[agenta]\n"\
  "  c[yan]\n"\
  "  gray,a\n"\
  "  d[ark_]gray,da\n"\
  "  l[ight_]red,lr\n"\
  "  l[ight_]green,lg\n"\
  "  l[ight_]blue,lb\n"\
  "  l[ight_]yellow,ly\n"\
  "  l[ight_]magenta,lm\n"\
  "  l[ight_]cyan,lc\n\n"\
" color map:\n"\
  "  default,Default\n"\
  "  rainbow\n"\
  "  Rainbow\n"\
  "  spectrum\n"\
  "  Spectrum\n\n"\
" rgb888 color:\n   Hexadecimal triplet: #[0-9a-fA-F]{6} (ex: '#22fa44')\n\n"\
" rgb444 color:\n   Hexadecimal triplet: #[0-9a-fA-F]{3}, (ex: '#ae3')\n\n"\
" 256 colors:\n   {0..255}\n\n"\
" ANSI/Escape color:\n   e{0..15}\n\n"\
" background prefix:\n   bg=\n\n"\
" example:\n"\
  "  echo abcdefgh | $0 '(..)..(..)' red,bg=#8f10e5,italic bg=yellow,k\n"\
  "  ls -shS ~/Videos | $0 -x 'log(v*(1000^u))' -u KMG '[0-9]+\.?[0-9]*.' Rainbow\n"\
  "  ls -shS ~/Videos | $0 -s 2000 -u KMG '[0-9]+\.?[0-9]*.' rainbow\n"\
  "  ls -l | $0 '(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)' B {r,g,y},{,i,o}\n"\
  "  echo \$LS_COLORS | $0 -r '([^=]+)=([^:]+:)'\n"\
  "  echo \$PATH | $0 -rn '([^:]+):'\n"\
  "  echo 'Progress [########################] 100%' | $0 -rn '#' hidden,bg=Rainbow\n"\
>&2
}

print_mode=0
all_mode=0

parse_cli () {
  line_mode=0
  scale_mode=0
  loop_color_mode=0
  continue_mode=0
  again_mode=0
  min_scale=0
  max_scale=100
  units=''
  user_expr=''
  user_scale_expr=''
  awk_user_funcs=''

  while getopts ':s:u:x:X:f:hlrcanpo' optname
  do
    case "$optname" in
      l) line_mode=1 ;;
      a) all_mode=1 ;;
      r) again_mode=1 ;;
      n) loop_color_mode=1 ;;
      c) continue_mode=1 ;;
      p) print_mode=1 ;;
      x) user_expr="$OPTARG" ;;
      X) user_scale_expr="$OPTARG" ;;
      f) awk_user_funcs="$OPTARG" ;;
      o) awk_opt="-o" ;;
      s)
        IFS=',' read min_scale max_scale <<<"$OPTARG"
        if [ -z "$max_scale" ] ; then
          max_scale="$min_scale"
          min_scale=0
        fi
        if [[
          ! "$min_scale" =~ ^[0-9]+$|^[0-9]+.?[0-9]*$|^[0-9]*.?[0-9]+$ ||
          ! "$max_scale" =~ ^[0-9]+$|^[0-9]+.?[0-9]*$|^[0-9]*.?[0-9]+$ ||
          "$max_scale" -lt "$min_scale"
        ]] ; then
          echo "-s $min_scale,$max_scale bad format"
          usage
          exit
        fi
        scale_mode=1
        ;;
      u) units="$OPTARG" ; scale_mode=1 ;;
      \?) break ;;
      :) echo "Option -$OPTARG requires an argument." >&2 ;  usage ; exit 1 ;;
      h) usage ; exit 1 ;;
    esac
  done
}

parse_cli "$@"
shift $(($OPTIND-1))

#if [ $# = 0 ] && [ $line_mode = 0 ] && [ $scale_mode = 0 ] ; then
if [ $# = 0 ] && [ $line_mode = 0 ] ; then
  usage
  exit 1
fi

if [ $line_mode = 1 ] ; then
  pattern=''
  append(){
    [ ! -z "$pattern" ] && pattern+=';n;'
    pattern+="s/^/\x1b0[${1}m/;s/$/\x1b[0m/"
  }
  run(){
    [ -z "$pattern" ] && append_color {31..37}
    local cmd
    [ $print_mode = 1 ] && cmd='echo' || cmd='exec'
    $cmd sed "$pattern" ;
  }
else
  rgx="$1"
  shift
  icol=0
  ireg=0
  colors=''
  append(){
    colors+="colors$ireg[$icol]=\"$1\";"
    ((++icol))
  }

  awk_script=''
  awk_begin_script=''
  awk_funcs=''
  [ $scale_mode = 1 ] && awk_begin_script="dscale=$max_scale-$min_scale;"
  s_i_unit='index("'$units'",substr(a[i], length(a[i]),1))'
  v_compute='*nb_colors'$ireg'/(dscale*'${#units}')'
  mk_rgx_block() {
    rgx=${rgx//\//\\/}
    [ -z "$colors" ] && append_color {31..37}

    local rep_start=''
    local rep_stop=''
    if [ $again_mode = 1 ] ; then
      rep_start='do {'
      rep_stop='$0 = substr($0, RSTART+RLENGTH) } while (match($0, /'"$rgx"'/, a))'
    fi

    local a_i_color='"\x1B[" colors'$ireg'['
    if [ ! -z "$user_expr" ] ; then
      local uexpr='{r=int('"$user_expr"')
        return r<0?0:(r>=nb_colors'$ireg'?nb_colors'$ireg'-1:r)}'
      if [ -z "$units" ] ; then
        a_i_color+='uexpr'$ireg'(a[i], nb_colors'$ireg')'
        awk_funcs+='function uexpr'$ireg'(v,n)'$uexpr
      else
        a_i_color+='uexpr'$ireg'(a[i], '$s_i_unit', nb_colors'$ireg')'
        awk_funcs+='function uexpr'$ireg'(v,u,n)'$uexpr
      fi
    elif [ ! -z "$user_scale_expr" ] ; then
      if [ -z "$units" ] ; then
        a_i_color+='uexpr'$ireg'(a[i])'$v_compute
        awk_funcs+='function uexpr'$ireg'(v){return '"$user_expr"'}'
      else
        a_i_color+='uexpr'$ireg'(a[i], '$s_i_unit')'$v_compute
        awk_funcs+='function uexpr'$ireg'(v,u){return '"$user_expr"'}'
      fi
    elif [ ! -z "$units" ] ; then
      a_i_color+='get_icol'$ireg'(a[i]-'$min_scale', '$s_i_unit')'
      awk_funcs+='function get_icol'$ireg'(v,u){
        istart=int((nb_colors'$ireg'/'${#units}')*(u>0?u-1:0))
        return int(istart+(v'$v_compute'))}'
    elif [ $scale_mode = 1 ] ; then
      a_i_color+='int((a[i] - '$min_scale')*nb_colors'$ireg'/dscale)'
    elif [ $loop_color_mode = 1 ] ; then
      a_i_color+='icol++%nb_colors'$ireg
    else
      a_i_color+='ic%nb_colors'$ireg
    fi
    a_i_color+='] "m" a[i] "\x1B[0m"'

    awk_begin_script+="$colors"' nb_colors'$ireg'='$icol';'
    [ $continue_mode = 0 ] && [ $ireg != 0 ] && awk_script+='else '
    awk_script+='
    if (match($0, /'"$rgx"'/, a)) {
      '"$rep_start"'
      n = length(a)/3
      if (n == 1) {
        i = 0
        ic= 0
        s = s substr($0, 0, RSTART-1) '"$a_i_color"'
      }
      else {
        c = ""
        p = 1
        for (i=1; i<n; ++i) {
          start=a[i,"start"]
          if (start == null) {
            ++n;
            continue
          }
          ic= i-1
          s = s substr($0, p, start-p) '"$a_i_color"'
          p = start+a[i,"length"]
        }
        s = s substr($0, p, RSTART+RLENGTH-p)
      }
      '"$rep_stop"'
      $0 = substr($0, RLENGTH+RSTART)
    }'
    ((++ireg))
    icol=0
    colors=''
  }

  run() {
    mk_rgx_block
    local pre_awk_script=''
    local post_awk_script=''
    if [ $all_mode = 1 ] ; then
      pre_awk_script='len=length($0); do {'
      post_awk_script='previous_len=len;len=length($0) } while (previous_len != len);'
    fi
    local cmd
    [ $print_mode = 1 ] && cmd='echo' || cmd='exec'
    $cmd awk $awk_opt "$awk_funcs
      $awk_user_funcs"'
      BEGIN { '"$awk_begin_script"' }
      { s="";'"$pre_awk_script $awk_script $post_awk_script"' print s $0 }'
  }
fi


declare -A style_names=(
  # styles

  [fgnormal]=0 [fgbold]=1 [fgdim]=2 [fgitalic]=3 [fgunderline]=4 [fgblink]=5 [fgreverse]=7 [fghidden]=8
  [fgn]=0 [fgo]=1 [fgd]=2 [fgi]=3 [fgu]=4 [fgl]=5 [fgv]=7 [fgh]=8

  [bgnormal]=0 [bgbold]=1 [bgdim]=2 [bgitalic]=3 [bgunderline]=4 [bgblink]=5 [bgreverse]=7 [bghidden]=8
  [bgn]=0 [bgo]=1 [bgd]=2 [bgi]=3 [bgu]=4 [bgl]=5 [bgv]=7 [bgh]=8


  # foreground

  [fgdefault]=39 [fgnone]=39

  [fgblack]=30 [fgred]=31 [fggreen]=32 [fgyellow]=33 [fgblue]=34 [fgmagenta]=35 [fgcyan]=36 [fggray]=37
  [fgk]=30 [fgr]=31 [fgg]=32 [fgy]=33 [fgb]=34 [fgm]=35 [fgc]=36 [fga]=37

  [fgdark_gray]=90 [fglight_red]=91 [fglight_green]=92 [fglight_yellow]=93 [fglight_blue]=94 [fglight_magenta]=95 [fglight_cyan]=96 [fgwhite]=97
  [fgdgray]=90 [fglred]=91 [fglgreen]=92 [fglyellow]=93 [fglblue]=94 [fglmagenta]=95 [fglcyan]=96
  [fgda]=90 [fglr]=91 [fglg]=92 [fgly]=93 [fglb]=94 [fglm]=95 [fglc]=96 [fgw]=97

  [fgbgdefault]=39 [fgbgnone]=39

  [fgbgblack]=30 [fgbgred]=31 [fgbggreen]=32 [fgbgyellow]=33 [fgbgblue]=34 [fgbgmagenta]=35 [fgbgcyan]=36 [fgbggray]=37
  [fgbgk]=30 [fgbgr]=31 [fgbgg]=32 [fgbgy]=33 [fgbgb]=34 [fgbgm]=35 [fgbgc]=36 [fgbga]=37

  [fgbgdark_gray]=90 [fgbglight_red]=91 [fgbglight_green]=92 [fgbglight_yellow]=93 [fgbglight_blue]=94 [fgbglight_magenta]=95 [fgbglight_cyan]=96 [fgbgwhite]=97
  [fgbgdgray]=90 [fgbglred]=91 [fgbglgreen]=92 [fgbglyellow]=93 [fgbglblue]=94 [fgbglmagenta]=95 [fgbglcyan]=96
  [fgbgda]=90 [fgbglr]=91 [fgbglg]=92 [fgbgly]=93 [fgbglb]=94 [fgbglm]=95 [fgbglc]=96 [fgbgw]=97

  [fge0]=30 [fge1]=31 [fge2]=32 [fge3]=33 [fge4]=34 [fge5]=35 [fge6]=36 [fge7]=37
  [fge8]=90 [fge9]=91 [fge10]=92 [fge11]=93 [fge12]=94 [fge13]=95 [fge14]=96 [fge15]=97


  # background

  [bgdefault]=49 [bgnone]=49

  [bgblack]=40 [bgred]=41 [bggreen]=42 [bgyellow]=43 [bgblue]=44 [bgmagenta]=45 [bgcyan]=46 [bggray]=47
  [bgk]=40 [bgr]=41 [bgg]=42 [bgy]=43 [bgb]=44 [bgm]=45 [bgc]=46 [bga]=47

  [bgdgray]=100 [bglred]=101 [bglgreen]=102 [bglyellow]=103 [bglblue]=104 [bglmagenta]=105 [bglcyan]=106 [bgwhite]=107
  [bgdark_gray]=100 [bglight_red]=101 [bglight_green]=102 [bglight_yellow]=103 [bglight_blue]=104 [bglight_magenta]=105 [bglight_cyan]=106 [bgwhite]=107
  [bgda]=100 [bglr]=101 [bglg]=102 [bgly]=103 [bglb]=104 [bglm]=105 [bglc]=106 [bgw]=107

  [bgbgdefault]=49 [bgbgnone]=49

  [bgbgblack]=40 [bgbgred]=41 [bgbggreen]=42 [bgbgyellow]=43 [bgbgblue]=44 [bgbgmagenta]=45 [bgbgcyan]=46 [bgbggray]=47
  [bgbgk]=40 [bgbgr]=41 [bgbgg]=42 [bgbgy]=43 [bgbgb]=44 [bgbgm]=45 [bgbgc]=46 [bgbga]=47

  [bgbgdgray]=100 [bgbglred]=101 [bgbglgreen]=102 [bgbglyellow]=103 [bgbglblue]=104 [bgbglmagenta]=105 [bgbglcyan]=106 [bgbgwhite]=107
  [bgbgdark_gray]=100 [bgbglight_red]=101 [bgbglight_green]=102 [bgbglight_yellow]=103 [bgbglight_blue]=104 [bgbglight_magenta]=105 [bgbglight_cyan]=106 [bgbgwhite]=107
  [bgbgda]=100 [bgbglr]=101 [bgbglg]=102 [bgbgly]=103 [bgbglb]=104 [bgbglm]=105 [bgbglc]=106 [bgbgw]=107

  [bge0]=40 [bge1]=41 [bge2]=42 [bge3]=43 [bge4]=44 [bge5]=45 [bge6]=46 [bge7]=47
  [bge8]=100 [bge9]=101 [bge10]=102 [bge11]=103 [bge12]=104 [bge13]=105 [bge14]=106 [bge15]=107
)


cmd='38'
prefix='fg'

append_color_name() {
  local c
  for c in $@ ; do
    append "$s;${style_names[$prefix$c]}"
  done
}
append_color256() {
  local c
  for c in $@ ; do
    append "$s;$cmd;5;$c"
  done
}
append_color() {
  local c
  for c in $@ ; do
    append "$s;$cmd;$c"
  done
}

while [ $# != 0 ] ; do
  # re-parse: "-- [-rg] [--] PATTERN [COLORS_AND_STYLES...]]..."
  if [ "$1" = '--' ] ; then
    if [ $line_mode = 1 ] ; then
      usage
      exit 5
    fi
    shift
    mk_rgx_block

    OPTIND=1
    parse_cli "$@"
    shift $(($OPTIND-1))

    if [ $# = 0 ] || [ $line_mode = 1 ] ; then
      usage
      exit 1
    fi

    rgx="$1"
    shift
    continue
  fi

  # note: "bg,red" is equivalent to "bg=red"
  IFS=',=' read -a styles <<<"$1"
  s=''
  for style in "${styles[@]}" ; do
    # background selector
    if [ bg = "$style" ] ; then
      cmd='48'
      prefix='bg'
    else
      v=${style_names[$prefix$style]}
      if [ -z "$v" ] ; then
        v2=${style_names[$prefix${style,,}]}
        # Bold and color
        if [ ! -z "$v2" ] ; then
          s+=";$v2;1"
        # rgb888 hexadecimal color (#ffffff)
        elif [[ "$style" =~ ^'#'[0-9a-fA-F]{6}$ ]] ; then
          rgb=$((16#${style:1}))
          s+=";$cmd;2;$(($rgb>>16));$((($rgb>>8)&0xff));$(($rgb&0xff))"
        # rgb444 hexadecimal color (#fff)
        elif [[ "$style" =~ ^'#'[0-9a-fA-F]{3}$ ]] ; then
          rgb=$((16#${style:1}))
          s+=";$cmd;2;$((($rgb>>8)*16));$(((($rgb>>4)&0xf)*16));$((($rgb&0xf)*16))"
        # 256 colors
        elif [[ "$style" =~ ^'25'[0-5]$|^[0-2][0-4][0-9]$|^[0-9][0-9]$ ]] ; then
          s+=";$cmd;5;${style:1}"
        else
          case "$style" in
            rainbow) append_color_name \
              m b c g y ; s+=";${style_names[${prefix}r]}" ;;
            Rainbow) append_color256 \
              92 93 57 21 27 33 39 45 51 50 49 48 47 46 82 118 154 190 226 220 214 208 202 ; s+="$s;$cmd;5;196" ;;
            spectrum) append_color_name \
              m b c w g y ; s+=";${style_names[${prefix}r]}" ;;
            Spectrum) append_color256 \
              91 92 56 57 21 27 26 32 31 37 36 35 41 40 41 77 83 84 120 121 157 194 231 254 255 231 230 229 228 227 226 220 214 208 202 ; s+="$s;$cmd;5;196" ;;
            default|Default) append_color {31..36} ; s+="$s;$cmd;37" ;;
            *) echo "Invalid '$style' color." >&2 ; exit 5 ;;
          esac
        fi
      else
        s+=";$v"
      fi
      cmd='38'
      prefix='fg'
    fi
  done
  append "$s"
  shift
done

run
